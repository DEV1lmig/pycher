[
  {
    "id": 1,
    "module_id": 1,
    "title": "Lección 1.1: ¡Hola, Mundo! Tu Primer Código en Python",
    "content": "**Objetivo:** Escribir tu primera línea de código funcional y entender los conceptos básicos del lenguaje para saber qué está ocurriendo.\n\n**¡Manos a la Obra! Tu Primer Programa**\nEn programación, el primer paso tradicional es crear un programa que muestre el mensaje \"¡Hola, mundo!\". Este simple acto confirma que tu entorno de Python está funcionando. Escribe esto en tu editor:\n```python\n# Esta línea muestra un mensaje en la pantalla.\nprint(\"¡Hola, mundo!\")\n```\nLa función `print()` es la forma en que le dices a Python que muestre algo. El texto que quieres mostrar, llamado **string**, va entre comillas.\nLa línea que comienza con `#` es un **comentario**. El intérprete la ignora, pero es una nota crucial para que tú u otros programadores entiendan el **\"porqué\"** del código.\n\n**¿Qué es Python y Por Qué es tan Relevante?**\nAhora que has escrito código, entendamos qué es Python. Es un lenguaje de programación de **alto nivel** (sintaxis parecida a la humana), **interpretado** (se ejecuta línea por línea, facilitando la depuración) y de **propósito general** (sirve para casi todo).\n\n* **Filosofía Clave:** \"La legibilidad cuenta\". Python está diseñado para ser claro y conciso, lo que lo hace ideal para principiantes y muy productivo para expertos.\n* **Versatilidad Extrema:** Se usa en:\n    * **Desarrollo Web** (Instagram, Spotify).\n    * **Ciencia de Datos e IA** (Netflix, Google).\n    * **Automatización** de tareas repetitivas.\n* **Comunidad y Ecosistema:** Cuenta con una comunidad global masiva y una enorme colección de librerías, lo que significa que casi siempre hay una herramienta ya hecha para lo que necesites.",
    "order_index": 1,
    "duration_minutes": 20
  },
  {
    "id": 2,
    "module_id": 1,
    "title": "Lección 1.2: Variables y Tipos de Datos Fundamentales",
    "content": "**Objetivo:** Enseñarte a almacenar y clasificar información usando variables y los tipos de datos básicos de Python.\n\n**Variables: Contenedores para tus Datos**\nUna **variable** es como una caja con una etiqueta. Guarda datos en la memoria del ordenador. La etiqueta es el nombre que le damos para poder referenciarla. Se crea usando el operador de asignación `=`.\n```python\nsaludo = \"Hola, de nuevo\"\nnumero_de_estudiantes = 30\n\nprint(saludo) # Muestra el contenido de la variable 'saludo'\nprint(numero_de_estudiantes)\n```\nPython usa **tipado dinámico**: no necesitas declarar el tipo de dato de antemano, el intérprete lo adivina por ti.\n\n**Tipos de Datos Esenciales**\nCada valor tiene un tipo, que define qué es y qué se puede hacer con él.\n* **String (`str`):** Texto. Se define con comillas simples `'...'` o dobles `\"...\"`.\n    * `nombre_usuario = \"Alex\"`\n* **Integer (`int`):** Números enteros, sin decimales.\n    * `edad = 25`\n* **Float (`float`):** Números con decimales.\n    * `precio_cafe = 1.50`\n* **Boolean (`bool`):** Representan uno de dos valores lógicos: `True` o `False` (con mayúscula inicial). Son la base para tomar decisiones.\n    * `es_nuevo_usuario = True`\n\n**La Herramienta de Diagnóstico: `type()`**\nSi tienes dudas, la función `type()` te dice a qué clase pertenece el valor de una variable.\n```python\nprint(type(nombre_usuario)) # Salida: <class 'str'>\nprint(type(edad))         # Salida: <class 'int'>\n```",
    "order_index": 2,
    "duration_minutes": 20
  },
  {
    "id": 3,
    "module_id": 1,
    "title": "Lección 1.3: Operaciones Básicas y Manipulación de Texto",
    "content": "**Objetivo:** Realizar operaciones matemáticas simples y aprender las técnicas fundamentales para trabajar con texto.\n\n**Operadores Aritméticos**\nUna vez que tienes datos numéricos en variables, puedes operar con ellos. Python usa operadores matemáticos estándar:\n* **Suma:** `+`\n* **Resta:** `-`\n* **Multiplicación:** `*`\n* **División:** `/`\n```python\nnumero1 = 10\nnumero2 = 3\n\nsuma = numero1 + numero2 # El valor de suma será 13\nresta = numero1 - numero2 # El valor de resta será 7\n\nprint(f\"La suma es: {suma}\") # Un ejemplo de f-string\n```\n\n**Trabajando con Strings: Concatenación y f-strings**\nManipular texto es una de las tareas más comunes.\n* **Concatenación:** Puedes 'sumar' o unir strings con el operador `+`.\n    ```python\n    nombre = \"Ana\"\n    apellido = \"García\"\n    nombre_completo = nombre + \" \" + apellido # Resultado: \"Ana García\"\n    print(nombre_completo)\n    ```\n* **f-strings (Strings Formateados):** Es la forma moderna y recomendada de incluir variables dentro de un texto. Es más legible y eficiente. Se crea poniendo una `f` antes de las comillas.\n    ```python\n    edad = 30\n    mensaje = f\"La usuaria {nombre} tiene {edad} años.\"\n    print(mensaje) # Resultado: \"La usuaria Ana tiene 30 años.\"\n    ```\nEsta técnica será tu mejor aliada para mostrar información de manera clara y dinámica.",
    "order_index": 3,
    "duration_minutes": 15
  },
  {
    "id": 4,
    "module_id": 2,
    "title": "Lección 2.1: Capturando Información del Usuario con `input()`",
    "content": "**Objetivo:** Aprender a hacer programas interactivos que pausen su ejecución para solicitar información al usuario.\n\n**Haciendo Programas que Escuchan**\nHasta ahora, nuestros programas han sido unidireccionales. Para darles vida, necesitamos que el usuario pueda ingresar datos. Para esto usamos la función `input()`.\nLa función `input()` hace dos cosas:\n1. Muestra en pantalla un mensaje (argumento opcional) para indicarle al usuario qué debe escribir.\n2. Pausa el programa y espera a que el usuario escriba algo y presione Enter.\n\n```python\nprint(\"Iniciando el programa...\")\n\nnombre_usuario = input(\"Por favor, ingresa tu nombre: \")\n\nprint(f\"¡Hola, {nombre_usuario}! Bienvenido al programa.\")\n```\n\n**El Detalle Crucial de `input()`**\n¡Atención! Sin importar lo que el usuario escriba (un nombre, un número, una fecha), la función `input()` **siempre** devuelve el dato como un **string (`str`)**. En la siguiente lección veremos por qué esto es tan importante y cómo manejarlo.",
    "order_index": 1,
    "duration_minutes": 15
  },
  {
    "id": 5,
    "module_id": 2,
    "title": "Lección 2.2: Conversión de Tipos (Casting)",
    "content": "**Objetivo:** Aprender a convertir datos de un tipo a otro, una habilidad esencial para poder realizar operaciones matemáticas con la información que nos da el usuario.\n\n**El Problema: No se Pueden Sumar Textos con Números**\nComo vimos, `input()` siempre devuelve un string. ¿Qué pasa si intentamos hacer esto?\n```python\nedad_str = input(\"Ingresa tu edad: \")\nanio_siguiente = edad_str + 1 # ¡Esto causará un error!\n```\nPython no puede sumar un texto ('25') con un número (1). Necesitamos 'traducir' el string a un número. A este proceso se le llama **conversión de tipo** o **casting**.\n\n**Las Herramientas de Conversión**\n* `int(valor)`: Intenta convertir `valor` a un número entero.\n* `float(valor)`: Intenta convertir `valor` a un número con decimales.\n* `str(valor)`: Convierte un valor (generalmente numérico) de vuelta a un string.\n\n**El Flujo Correcto**\n1. Recibir la entrada como string con `input()`.\n2. Convertir el string al tipo numérico deseado (`int` o `float`).\n3. Realizar las operaciones matemáticas.\n```python\n# 1. Recibir\nedad_str = input(\"Ingresa tu edad: \")\n\n# 2. Convertir\nedad_num = int(edad_str)\n\n# 3. Operar\nanio_siguiente = edad_num + 1\nprint(f\"El próximo año tendrás {anio_siguiente} años.\")\n```",
    "order_index": 2,
    "duration_minutes": 20
  },
  {
    "id": 6,
    "module_id": 2,
    "title": "Lección 2.3: Operadores de Comparación y Lógicos",
    "content": "**Objetivo:** Aprender a comparar valores y a combinar estas comparaciones, lo que nos devolverá un resultado Booleano (`True` o `False`) que usaremos para tomar decisiones.\n\n**Comparando Valores**\nPara que un programa pueda decidir, primero debe poder comparar. Estos operadores comparan dos valores y el resultado siempre es `True` o `False`.\n* `==` (Igual a)\n* `!=` (Distinto de)\n* `>` (Mayor que)\n* `<` (Menor que)\n* `>=` (Mayor o igual que)\n* `<=` (Menor o igual que)\n\n```python\nedad = 20\nprint(edad > 18)  # Salida: True\nprint(edad == 18) # Salida: False\n```\n\n**Combinando Condiciones con Operadores Lógicos**\nA menudo necesitamos verificar más de una condición a la vez.\n* **`and`**: Devuelve `True` solo si **ambas** condiciones son verdaderas.\n    * `(edad > 18) and (tiene_licencia == True)`\n* **`or`**: Devuelve `True` si **al menos una** de las condiciones es verdadera.\n    * `es_fin_de_semana or es_feriado`\n* **`not`**: Invierte el valor booleano (de `True` a `False` y viceversa).\n    * `not esta_lloviendo`\n\nEstos operadores son la base de la lógica que veremos en la siguiente lección.",
    "order_index": 3,
    "duration_minutes": 15
  },
  {
    "id": 7,
    "module_id": 2,
    "title": "Lección 2.4: Tomando Decisiones con `if`, `elif` y `else`",
    "content": "**Objetivo:** Utilizar las comparaciones para controlar qué bloques de código se ejecutan, permitiendo que el programa tome diferentes caminos.\n\n**La Sentencia `if` (Si...):**\nEjecuta un bloque de código **únicamente si** la condición evaluada es `True`. La sintaxis requiere dos puntos `:` y que el bloque de código esté **indentado** (generalmente 4 espacios).\n```python\nedad = int(input(\"Ingresa tu edad: \"))\n\nif edad >= 18:\n    print(\"Acceso permitido. Eres mayor de edad.\")\n```\n\n**La Sentencia `else` (...si no):**\nProporciona un camino alternativo que se ejecuta si la condición del `if` es `False`.\n```python\ntemperatura = 15\nif temperatura > 25:\n    print(\"Es un día caluroso.\")\nelse:\n    print(\"El clima es fresco.\")\n```\n\n**Encadenando Condiciones con `elif` (...o si no, si...):**\nPermite revisar múltiples condiciones en orden. Python ejecuta el bloque de la primera condición `True` que encuentra y luego ignora el resto.\n```python\nnota = 75\nif nota >= 90:\n    print(\"Calificación: A\")\nelif nota >= 80:\n    print(\"Calificación: B\")\nelif nota >= 70:\n    print(\"Calificación: C\") # Esta se ejecuta y el resto se ignora.\nelse:\n    print(\"Calificación: F\")\n```",
    "order_index": 4,
    "duration_minutes": 20
  },
  {
    "id": 8,
    "module_id": 3,
    "title": "Lección 3.1: Bucles `while` y Repetición Basada en Condiciones",
    "content": "**Objetivo:** Aprender a ejecutar un bloque de código repetidamente mientras una condición sea verdadera, ideal para situaciones donde no sabemos cuántas iteraciones necesitamos.\n\n**El Bucle `while` (Mientras...):**\nEl bucle `while` es tu herramienta para repetir tareas de duración indefinida. Su estructura es muy parecida a la de un `if`: ejecuta el bloque de código indentado mientras la condición booleana sea `True`.\n```python\ncontador = 0\n\nwhile contador < 5:\n    print(f\"El contador es {contador}. Aún no llegamos a 5.\")\n    contador = contador + 1 # ¡Línea crítica!\n\nprint(\"¡Fin! El contador llegó a 5.\")\n```\n\n**¡Cuidado con los Bucles Infinitos!**\nEs **fundamental** que dentro del bucle haya una línea que modifique la variable de la condición. Si en el ejemplo anterior olvidamos `contador = contador + 1`, la condición `contador < 5` siempre sería `True` y el programa se quedaría atrapado repitiendo el `print` para siempre. \n\n**`break`: La Salida de Emergencia**\nPuedes usar la palabra clave `break` para salir forzosamente de un bucle, incluso si su condición sigue siendo verdadera. Es útil para detener la repetición cuando se cumple un objetivo específico.\n```python\nwhile True: # Un bucle infinito intencional\n    respuesta = input(\"Escribe 'salir' para terminar: \")\n    if respuesta == \"salir\":\n        break # Interrumpe el bucle\nprint(\"Programa terminado.\")\n```",
    "order_index": 1,
    "duration_minutes": 20
  },
  {
    "id": 9,
    "module_id": 3,
    "title": "Lección 3.2: Bucles `for` e Iteración sobre Secuencias",
    "content": "**Objetivo:** Aprender a iterar (recorrer) sobre una secuencia de elementos finita. Es la forma más común y segura de realizar bucles en Python.\n\n**El Bucle `for` (Para cada...):**\nA diferencia del `while`, el bucle `for` está diseñado para recorrer colecciones de elementos. Su estructura es: `for variable_temporal in coleccion:`.\n\n**Iterando con `range()`**\nLa función `range()` genera una secuencia de números, ideal para repetir una acción un número exacto de veces.\n`range(fin)`: Genera números desde 0 hasta `fin - 1`.\n`range(inicio, fin)`: Genera números desde `inicio` hasta `fin - 1`.\n\n```python\n# Repetir una acción 5 veces\nfor numero in range(5): # Genera 0, 1, 2, 3, 4\n    print(f\"Esta es la repetición número {numero}\")\n\n# Iterar sobre los caracteres de un string\nfor letra in \"Python\":\n    print(letra)\n```\nCon el bucle `for`, no necesitas gestionar una variable contador manualmente, lo que lo hace menos propenso a errores de bucles infinitos.\n\n**`continue`: Saltando a la Siguiente Iteración**\nLa palabra clave `continue` detiene la iteración actual y salta inmediatamente a la siguiente, ignorando el resto del código del bloque.\n```python\nfor i in range(1, 11):\n    if i % 2 != 0: # Si el número es impar\n        continue   # Sáltate el print y ve al siguiente número\n    print(i) # Solo se ejecuta para números pares\n```",
    "order_index": 2,
    "duration_minutes": 20
  },
  {
    "id": 10,
    "module_id": 3,
    "title": "Lección 3.3: Introducción a las Listas",
    "content": "**Objetivo:** Aprender a usar las listas, la estructura de datos más versátil de Python, para almacenar colecciones ordenadas y modificables de elementos.\n\nUna **lista** es una colección **ordenada** y **mutable** de elementos.\n- **Ordenada:** Los elementos mantienen el orden en que fueron añadidos.\n- **Mutable:** Puedes cambiar su contenido: añadir, eliminar o modificar elementos después de su creación.\n\n**Creación y Acceso a Elementos**\nSe crean con corchetes `[]`. Para acceder a un elemento, se usa su **índice** (posición), que siempre empieza en `0`.\n```python\nfrutas = [\"manzana\", \"banana\", \"cereza\"]\n# Índices:    0          1          2\n\nprimer_fruta = frutas[0] # Accede a \"manzana\"\nprint(f\"La primera fruta es: {primer_fruta}\")\n\n# Modificar un elemento\nfrutas[1] = \"arándano\" # Reemplaza \"banana\"\n```\n\n**Manipulación Básica**\n* `.append(elemento)`: Añade un elemento al final de la lista.\n* `.remove(valor)`: Elimina la primera ocurrencia de un valor.\n* `len(lista)`: Devuelve el número de elementos en la lista.\n```python\nfrutas.append(\"naranja\")\nprint(f\"Lista actualizada: {frutas}\")\nprint(f\"Ahora hay {len(frutas)} frutas.\")\n```\n\n**Recorriendo una Lista con un Bucle `for`**\nEl bucle `for` es la forma natural de procesar cada elemento de una lista.\n```python\nfor fruta in frutas:\n    print(f\"- {fruta.capitalize()}\")\n```",
    "order_index": 3,
    "duration_minutes": 20
  },
  {
    "id": 11,
    "module_id": 3,
    "title": "Lección 3.4: Introducción a las Funciones",
    "content": "**Objetivo:** Aprender a crear bloques de código reutilizables para organizar el programa, hacerlo más legible y evitar repetir código.\n\nUna **función** es un bloque de código organizado que realiza una tarea específica. Se define con la palabra clave `def` y se 'llama' o 'ejecuta' usando su nombre seguido de paréntesis.\n\n**Definición y Llamada**\n```python\ndef mostrar_menu():\n    print(\"1. Iniciar juego\")\n    print(\"2. Ver puntajes\")\n    print(\"3. Salir\")\n\nprint(\"Bienvenido al programa\")\nmostrar_menu() # Llamamos a la función para que ejecute su código\n```\n\n**Parámetros y Argumentos: Pasando Información**\nLas funciones se vuelven realmente poderosas cuando pueden recibir datos.\n- **Parámetros:** Son las variables que se definen en la firma de la función.\n- **Argumentos:** Son los valores reales que se le pasan al llamar la función.\n```python\ndef saludar(nombre_usuario): # 'nombre_usuario' es el parámetro\n    print(f\"¡Hola, {nombre_usuario}! Qué bueno verte.\")\n\nsaludar(\"Ana\") # \"Ana\" es el argumento\nsaludar(\"Luis\")\n```\n\n**Retornando un Resultado con `return`**\nLas funciones pueden procesar datos y devolver un valor al código que las llamó.\n```python\ndef calcular_area_cuadrado(lado):\n    area = lado * lado\n    return area # Devuelve el valor calculado\n\narea_calculada = calcular_area_cuadrado(5)\nprint(f\"El área de un cuadrado de lado 5 es {area_calculada}\")\n```",
    "order_index": 4,
    "duration_minutes": 25
  },
  {
    "id": 12,
    "module_id": 5,
    "title": "Lección 1.1: Acceso a Elementos en Tuplas",
    "content": "Una **tupla** es una colección **ordenada** e **inmutable** de elementos. 'Ordenada' significa que cada elemento tiene una posición fija, identificada por un **índice**. 'Inmutable' significa que una vez creada, no se puede modificar.\n\n**¿Cuándo usar tuplas?** Son ideales para datos que no deben cambiar, como coordenadas geográficas `(lat, lon)`, colores RGB `(255, 0, 0)` o registros de una base de datos.\n\n### Índices Positivos\nComienzan en `0` para el primer elemento.\n```python\ncolores = (\"rojo\", \"verde\", \"azul\")\n# Index:    0        1       2\nprint(colores[0])  # Muestra: \"rojo\"\n```\n\n### Índices Negativos\nComienzan en `-1` para el último elemento. Son muy convenientes para acceder al final de la secuencia sin saber su longitud.\n```python\nprint(colores[-1]) # Muestra: \"azul\"\n```\n\n### `IndexError`: Un Error Común\nSi intentas acceder a un índice que no existe, Python lanzará un error `IndexError`. Esto detiene la ejecución y te informa que estás tratando de acceder a una posición fuera de los límites de la tupla.\n```python\n# Esto causará un error porque el índice 3 no existe.\n# print(colores[3])\n```",
    "order_index": 1,
    "duration_minutes": 20
  },
  {
    "id": 13,
    "module_id": 5,
    "title": "Lección 1.2: Sets: Colecciones de Elementos Únicos",
    "content": "Un **set** (o conjunto) es una colección **no ordenada** de elementos **únicos**. Su principal fortaleza es la optimización para verificar si un elemento está presente en la colección (pertenencia) y la eliminación de duplicados.\n\n### Creación y Propiedad de Unicidad\nSe definen con llaves `{}` o con `set()`. Cualquier elemento duplicado en la definición es descartado automáticamente.\n```python\n# Los duplicados '2' y '1' son ignorados\nnumeros = {1, 2, 3, 2, 4, 1}\nprint(numeros)  # Resultado: {1, 2, 3, 4}\n\n# Eliminar duplicados de una lista\nlista_invitados = [\"Ana\", \"Luis\", \"Ana\", \"Pedro\"]\ninvitados_unicos = set(lista_invitados)\nprint(invitados_unicos) # Resultado: {'Ana', 'Luis', 'Pedro'}\n```\n\n### Operaciones de Conjuntos\nLos sets brillan al realizar operaciones matemáticas de teoría de conjuntos de forma muy eficiente.\n* **Unión (`|`):** Elementos que están en A, o en B, o en ambos.\n* **Intersección (`&`):** Elementos que están tanto en A como en B.\n* **Diferencia (`-`):** Elementos que están en A pero no en B.\n\n```python\nset_a = {1, 2, 3}\nset_b = {3, 4, 5}\n\nprint(f\"Unión: {set_a | set_b}\")\nprint(f\"Intersección: {set_a & set_b}\")\nprint(f\"Diferencia: {set_a - set_b}\")\n```",
    "order_index": 2,
    "duration_minutes": 20
  },
  {
    "id": 14,
    "module_id": 5,
    "title": "Lección 1.3: Diccionarios: Pares Clave-Valor",
    "content": "Un **diccionario** es una estructura de datos que almacena información en pares `clave: valor`. A diferencia de las listas o tuplas que se indexan por posición numérica, los diccionarios se indexan mediante **claves** únicas.\n\n**Características Principales:**\n- **Rápidos:** Optimizados para recuperar valores cuando se conoce la clave.\n- **Mutables:** Se pueden modificar después de su creación.\n- **Dinámicos:** Pueden crecer y decrecer en tamaño.\n\n### Creación y Acceso a Valores\n```python\n# Las claves suelen ser strings, pero pueden ser cualquier tipo inmutable.\nconfiguracion = {\n    \"usuario\": \"admin\",\n    \"tema\": \"oscuro\",\n    \"notificaciones_activas\": True\n}\n\n# Se accede al valor a través de su clave\nprint(configuracion[\"tema\"])   # Muestra: oscuro\n```\n\n### Modificación y Recorrido\n```python\n# Modificar un valor existente\nconfiguracion[\"tema\"] = \"claro\"\n\n# Agregar un nuevo par clave-valor\nconfiguracion[\"idioma\"] = \"es\"\n\n# La forma más eficiente de iterar es con el método .items()\n# Devuelve una tupla (clave, valor) en cada iteración\nfor clave, valor in configuracion.items():\n    print(f\"- {clave.capitalize()}: {valor}\")\n```",
    "order_index": 3,
    "duration_minutes": 20
  },
  {
    "id": 15,
    "module_id": 6,
    "title": "Lección 2.1: Listas de Listas (Matrices)",
    "content": "Una **lista de listas** es una estructura de datos de dos dimensiones donde cada elemento de la lista principal es, a su vez, otra lista. Esto es extremadamente útil para representar estructuras tabulares como hojas de cálculo, tableros de juego o matrices matemáticas.\n\n### Representación de una Matriz\n```python\n# Una matriz de 3x3\nmatriz = [\n    [1, 2, 3],  # Fila 0\n    [4, 5, 6],  # Fila 1\n    [7, 8, 9]   # Fila 2\n]\n```\n\n### Acceso a Elementos\nPara acceder a un elemento, se utiliza una doble indexación: `matriz[indice_fila][indice_columna]`.\n```python\n# Acceder al elemento en la Fila 1, Columna 2\nvalor = matriz[1][2]\nprint(valor)  # Muestra: 6\n\n# Acceder a una fila completa\nfila_completa = matriz[0]\nprint(fila_completa) # Muestra: [1, 2, 3]\n```\n\n### Recorrido con Bucles Anidados\nPara procesar cada elemento de la matriz, se necesitan dos bucles `for` anidados. El bucle exterior itera sobre las filas, y el interior sobre los elementos (columnas) de cada fila.\n```python\nfor fila in matriz:\n    for elemento in fila:\n        print(elemento, end=\"\\t\") # '\\t' es un tabulador para alinear\n    print()  # Salto de línea al final de cada fila\n```",
    "order_index": 1,
    "duration_minutes": 20
  },
  {
    "id": 16,
    "module_id": 6,
    "title": "Lección 2.2: Diccionarios de Listas",
    "content": "Un **diccionario de listas** es una poderosa estructura que combina la búsqueda rápida por clave de los diccionarios con la flexibilidad de las listas. En esta estructura, el valor asociado a cada clave es una lista.\n\n### Caso de Uso: Agrupar Datos\nEs perfecto para agrupar colecciones de elementos bajo una categoría específica. Por ejemplo, agrupar estudiantes por materia o productos por categoría.\n```python\n# Ejemplo: Agrupar jugadores por equipo\nequipos = {\n    \"futbol\": [\"Messi\", \"Ronaldo\", \"Neymar\"],\n    \"basquet\": [\"LeBron\", \"Curry\"]\n}\n```\n\n### Acceso y Manipulación\n1.  Se accede a la lista completa usando la clave del diccionario.\n2.  Una vez obtenida la lista, se pueden usar todos los métodos de lista conocidos (`.append()`, `.remove()`, etc.).\n\n```python\n# Obtener la lista de jugadores de basquet\njugadores_basquet = equipos[\"basquet\"]\nprint(jugadores_basquet)  # Muestra: ['LeBron', 'Curry']\n\n# Agregar un nuevo jugador al equipo de futbol\nequipos[\"futbol\"].append(\"Mbappé\")\nprint(equipos[\"futbol\"])  # Muestra la lista actualizada\n\n# Crear una nueva categoría\nequipos[\"tenis\"] = [\"Nadal\", \"Federer\"]\n```",
    "order_index": 2,
    "duration_minutes": 20
  },
  {
    "id": 17,
    "module_id": 6,
    "title": "Lección 2.3: Recorriendo Estructuras Anidadas",
    "content": "Para procesar la información contenida en **estructuras anidadas**, como una matriz o un diccionario de listas, la técnica fundamental es el uso de **ciclos anidados**. Cada nivel de anidación en la estructura de datos generalmente requiere un bucle `for` adicional para ser recorrido.\n\n### Recorrer una Matriz (Lista de Listas)\nEl bucle exterior itera a través de cada sublista (fila), y el bucle interior itera a través de cada elemento dentro de esa sublista.\n```python\nmatriz = [[10, 20], [30, 40]]\n\nfor fila in matriz:\n    print(f\"Procesando fila: {fila}\")\n    for elemento in fila:\n        print(f\"  - Elemento: {elemento}\")\n```\n\n### Recorrer un Diccionario de Listas\nSe utiliza el método `.items()` para obtener la clave y el valor (la lista) simultáneamente en el bucle exterior. El bucle interior luego itera sobre la lista.\n```python\nproductos = {\n    \"frutas\": [\"manzana\", \"pera\"],\n    \"verduras\": [\"zanahoria\", \"espinaca\"]\n}\n\nfor categoria, lista_productos in productos.items():\n    print(f\"\\nCategoría: {categoria.upper()}\")\n    for producto in lista_productos:\n        print(f\"  - {producto}\")\n```",
    "order_index": 3,
    "duration_minutes": 20
  },
  {
    "id": 18,
    "module_id": 7,
    "title": "Lección 3.1: Manejo de Errores con try/except",
    "content": "Una **excepción** es un evento que ocurre durante la ejecución de un programa que interrumpe su flujo normal. Si no se maneja, la excepción detendrá el programa. El bloque `try/except` es el mecanismo de Python para manejar estas situaciones de forma segura.\n\n### El Flujo de Ejecución\n1.  Python ejecuta el código dentro del bloque **`try`**.\n2.  **Si no ocurre ninguna excepción**, el bloque `except` se ignora y la ejecución continúa normalmente después del bloque `try/except`.\n3.  **Si ocurre una excepción**, Python detiene la ejecución del bloque `try` inmediatamente y busca un bloque `except` que coincida con el tipo de excepción. Si lo encuentra, ejecuta el código de ese bloque.\n\n### Ejemplo Práctico: `ValueError`\n```python\ntry:\n    # Intentamos una operación que puede fallar\n    edad_str = input(\"Ingrese su edad: \")\n    edad = int(edad_str)\n    print(\"Operación exitosa.\")\nexcept ValueError:\n    # Este código solo se ejecuta si int() falla\n    print(\"Error: La entrada no es un número válido.\")\n\nprint(\"El programa continúa...\")\n```\nEste enfoque se conoce como \"pedir perdón en lugar de permiso\". En lugar de verificar de antemano si la conversión es posible, intentamos la operación y manejamos el error si ocurre.",
    "order_index": 1,
    "duration_minutes": 20
  },
  {
    "id": 19,
    "module_id": 7,
    "title": "Lección 3.2: Captura de Errores Específicos",
    "content": "Capturar excepciones de forma genérica (`except:`) es posible, pero es una mala práctica porque oculta la naturaleza del error. Es mucho mejor especificar el tipo de excepción que se espera, lo que permite dar una respuesta adecuada para cada tipo de problema.\n\n### Jerarquía de Excepciones\nLas excepciones en Python están organizadas en una jerarquía. Por ejemplo, `ValueError` y `ZeroDivisionError` son tipos más específicos de la clase base `Exception`.\n\n### Capturando Múltiples Tipos de Error\nSe pueden encadenar varios bloques `except` para manejar diferentes tipos de excepciones de forma independiente.\n```python\ntry:\n    dividendo = int(input(\"Ingresa el dividendo: \"))\n    divisor = int(input(\"Ingresa el divisor: \"))\n    resultado = dividendo / divisor\n    print(f\"El resultado es: {resultado}\")\n\nexcept ValueError:\n    # Se ejecuta si int() falla\n    print(\"Error de tipo: Por favor, ingresa solo números enteros.\")\n\nexcept ZeroDivisionError:\n    # Se ejecuta si el divisor es 0\n    print(\"Error matemático: No se puede dividir entre cero.\")\n\nexcept Exception as e:\n    # Bloque genérico opcional para cualquier otro error\n    print(f\"Ha ocurrido un error inesperado: {e}\")\n```\nEl orden importa: Python usará el primer bloque `except` que coincida.",
    "order_index": 2,
    "duration_minutes": 20
  },
  {
    "id": 20,
    "module_id": 7,
    "title": "Lección 3.3: Bloque `finally` y Lanzamiento de Errores con `raise`",
    "content": "### El Bloque `finally`: Garantizando la Ejecución\nEl bloque `finally` contiene código que se ejecutará **siempre** al salir de un bloque `try/except`, sin importar si ocurrió una excepción o no. Su propósito principal es realizar acciones de 'limpieza', como cerrar archivos o conexiones de red, para asegurar que los recursos se liberen correctamente.\n\n```python\ntry:\n    print(\"Intentando realizar una operación...\")\n    # x = 1 / 0 # Descomenta para probar el error\nexcept ZeroDivisionError:\n    print(\"Error: División por cero detectada.\")\nfinally:\n    print(\"Limpieza: Este bloque se ejecuta siempre.\")\n```\n\n### `raise`: Señalando un Problema\nMientras que `except` *maneja* un problema, `raise` *crea* o *señala* uno. Permite lanzar una excepción de forma explícita cuando una condición de nuestro programa no se cumple. Es fundamental para la validación de datos.\n\n```python\ntry:\n    edad = int(input(\"Ingrese su edad: \"))\n    if edad < 0:\n        # Lanzamos una excepción porque la condición lógica es inválida\n        raise ValueError(\"La edad no puede ser un número negativo.\")\n    print(f\"Edad ingresada correctamente: {edad}\")\n\nexcept ValueError as error_lanzado:\n    # Capturamos la excepción que nosotros mismos (o Python) lanzamos\n    print(f\"Error de validación: {error_lanzado}\")\n```",
    "order_index": 3,
    "duration_minutes": 20
  },
  {
    "id": 21,
    "module_id": 7,
    "title": "Lección 3.4: List Comprehensions para Transformar Listas",
    "content": "Las **List Comprehensions** (comprensiones de listas) son una de las características más apreciadas de Python. Proporcionan una sintaxis concisa y legible para crear una nueva lista a partir de un iterable existente.\n\n### Desglose de la Sintaxis\n`nueva_lista = [expresion_de_salida for elemento in iterable if condicion]`\n- **`expresion_de_salida`**: La operación que se aplica a cada elemento para crear el nuevo valor.\n- **`for elemento in iterable`**: El bucle que recorre la secuencia original.\n- **`if condicion`** (Opcional): Un filtro que decide si el elemento debe ser procesado o no.\n\n### Comparación: `for` vs. List Comprehension\nImaginemos que queremos obtener una lista con los nombres de frutas en mayúsculas, pero solo si tienen más de 5 letras.\n\n**1. Con un Bucle `for` tradicional:**\n```python\nfrutas = [\"manzana\", \"pera\", \"banana\", \"kiwi\"]\nnombres_largos_mayusculas = []\nfor fruta in frutas:\n    if len(fruta) > 5:\n        nombres_largos_mayusculas.append(fruta.upper())\nprint(nombres_largos_mayusculas) # ['MANZANA', 'BANANA']\n```\n\n**2. Con una List Comprehension:**\n```python\nfrutas = [\"manzana\", \"pera\", \"banana\", \"kiwi\"]\nnombres_largos_mayusculas = [fruta.upper() for fruta in frutas if len(fruta) > 5]\nprint(nombres_largos_mayusculas) # ['MANZANA', 'BANANA']\n```\nEl resultado es el mismo, pero la versión con list comprehension es más compacta y, para muchos, más fácil de leer una vez que se entiende la sintaxis.",
    "order_index": 4,
    "duration_minutes": 20
  },
  {
    "id": 22,
    "module_id": 7,
    "title": "Lección 3.5: Funciones `lambda` para Operaciones Rápidas",
    "content": "Una **función lambda** es una función pequeña y anónima. 'Anónima' porque no se define con la palabra clave `def`. Se limita a una sola expresión y se usa a menudo donde se requiere una función como argumento por un corto tiempo.\n\n**Sintaxis:** `lambda argumentos: expresion`\n\n### Caso de Uso 1: `sorted()`\nLa función `sorted()` ordena un iterable. Su argumento `key` espera una función que extraiga la 'clave' de ordenación de cada elemento. `lambda` es perfecta para esto.\n\n```python\n# Ordenar una lista de diccionarios por el valor de 'edad'\npersonas = [\n    {'nombre': 'Ana', 'edad': 29},\n    {'nombre': 'Luis', 'edad': 25}\n]\n\nordenado_por_edad = sorted(personas, key=lambda persona: persona['edad'])\nprint(ordenado_por_edad)\n```\nLa `lambda` le dice a `sorted`: \"Para cada diccionario 'persona', usa el valor de 'edad' para comparar y ordenar\".\n\n### Caso de Uso 2: `filter()`\nLa función `filter()` construye un iterador a partir de los elementos de un iterable para los cuales una función devuelve `True`. `lambda` define esta función de filtrado de forma concisa.\n\n```python\nnumeros = [1, 2, 3, 4, 5, 6]\n\n# Filtrar solo los números pares\npares = list(filter(lambda num: num % 2 == 0, numeros))\nprint(pares)  # Muestra: [2, 4, 6]\n```\nLa `lambda` `num: num % 2 == 0` es la función de condición que `filter` aplica a cada número.",
    "order_index": 5,
    "duration_minutes": 20
  },
  {
    "id": 23,
    "module_id": 9,
    "title": "Lección 1.1: De Tuplas a Clases de Datos: Estructurando la Información",
    "content": "**Objetivo:** Entender la necesidad de las clases para agrupar datos y comportamientos, y aprender a usar `@dataclass` como una forma moderna y eficiente de crear clases centradas en datos.\n\n### El Problema: Datos Desconectados\nLas tuplas y diccionarios son geniales para almacenar datos, pero no ofrecen una forma de asociarles un comportamiento (funciones). Si tenemos varios puntos, ¿cómo calculamos la distancia entre ellos?\n```python\npunto_a = (10, 20)\npunto_b = (15, 25)\n# La lógica para calcular la distancia está separada de los datos.\n```\n\n### La Solución: Agrupar Datos y Comportamiento con Clases\nUna **clase** es una plantilla para crear **objetos**. Nos permite definir una estructura de datos (atributos) y las funciones que operan sobre esos datos (métodos).\n\n### `@dataclass`: El Camino Rápido y Moderno\nEscribir los métodos básicos de una clase (`__init__`, `__repr__`) es repetitivo. El módulo `dataclasses` lo hace por nosotros.\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass Punto:\n    x: int\n    y: int\n\n    def distancia_al_origen(self):\n        return (self.x**2 + self.y**2)**0.5\n\n# Crear una instancia (objeto) es simple e intuitivo\np1 = Punto(3, 4)\nprint(p1) # La representación es útil y automática: Punto(x=3, y=4)\nprint(f\"Distancia al origen: {p1.distancia_al_origen()}\") # 5.0\n```",
    "order_index": 1,
    "duration_minutes": 25
  },
  {
    "id": 24,
    "module_id": 9,
    "title": "Lección 1.2: Inmutabilidad y Métodos Funcionales en Clases",
    "content": "**Objetivo:** Aprender a diseñar clases con un enfoque funcional, priorizando la inmutabilidad y creando métodos que devuelven nuevas instancias en lugar de modificar las existentes.\n\n### Estado Mutable vs. Inmutable\n- **Mutable (Tradicional):** Un objeto que puede cambiar su estado interno. Esto puede generar efectos secundarios difíciles de rastrear.\n    ```python\n    # Un objeto que 'muta'\n    mi_cuenta.depositar(100) # El estado interno de mi_cuenta cambia.\n    ```\n- **Inmutable (Funcional):** Un objeto cuyo estado no puede cambiar después de su creación. Para 'modificarlo', se crea una nueva instancia con los datos actualizados. Esto hace el código más predecible.\n\n### Implementando Inmutabilidad con `@dataclass(frozen=True)`\nEste decorador convierte a nuestra clase en inmutable. Cualquier intento de modificar un atributo después de la creación lanzará un error.\n```python\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass Usuario:\n    nombre: str\n    activo: bool = False\n\n    def activar(self):\n        # No modificamos 'self', creamos un nuevo usuario\n        return Usuario(self.nombre, True)\n\n# Flujo de trabajo inmutable\nusuario_inactivo = Usuario(\"Carlos\")\nprint(f\"Antes: {usuario_inactivo}\")\n\nusuario_activado = usuario_inactivo.activar()\nprint(f\"Después: {usuario_activado}\")\nprint(f\"Original sin cambios: {usuario_inactivo}\")\n```\nEste enfoque evita errores al asegurar que los objetos originales nunca se alteren.",
    "order_index": 2,
    "duration_minutes": 25
  },
  {
    "id": 25,
    "module_id": 9,
    "title": "Lección 1.3: Comportamiento y Propiedades Computadas",
    "content": "**Objetivo:** Añadir métodos que realicen cálculos basados en los atributos de un objeto y exponerlos de forma elegante usando el decorador `@property`.\n\nUna vez que tenemos nuestros datos estructurados en una clase (preferiblemente inmutable), podemos añadirle comportamientos.\n\n### Métodos que Calculan\nEstos métodos usan los atributos del objeto (`self.x`, `self.y`, etc.) para realizar un cálculo y devolver un resultado, sin modificar el estado.\n```python\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass Rectangulo:\n    largo: float\n    ancho: float\n\n    def calcular_area(self):\n        return self.largo * self.ancho\n```\n\n### `@property`: Métodos que Parecen Atributos\nA veces, un cálculo está tan ligado a los datos del objeto que se siente como un atributo más. El decorador `@property` nos permite llamar a un método sin usar paréntesis, haciéndolo parecer un atributo de solo lectura.\n```python\n@dataclass(frozen=True)\nclass Rectangulo:\n    largo: float\n    ancho: float\n\n    @property\n    def area(self):\n        print(\"(Calculando área...)\") # Se ejecuta cada vez que se accede\n        return self.largo * self.ancho\n\n# Uso\nrect = Rectangulo(10, 5)\nprint(f\"El área es: {rect.area}\") # Se llama como un atributo, no como rect.area()\nprint(f\"De nuevo, el área es: {rect.area}\")\n```\nEsto proporciona una interfaz limpia y protege el cálculo, ya que no se puede asignar un valor a `rect.area`.",
    "order_index": 3,
    "duration_minutes": 20
  },
  {
    "id": 26,
    "module_id": 10,
    "title": "Lección 2.1: Funciones de Orden Superior y Decoradores",
    "content": "**Objetivo:** Entender que las funciones son 'ciudadanos de primera clase' en Python y usar este concepto para construir decoradores que modifican o extienden el comportamiento de otras funciones.\n\n### Funciones como Objetos\nEn Python, las funciones no son solo bloques de código; son objetos. Esto significa que puedes:\n- Asignarlas a una variable.\n- Almacenarlas en una colección (lista, diccionario).\n- Pasarlas como argumento a otra función.\n- Devolverlas desde otra función.\n\nEsta capacidad es la piedra angular de la programación funcional y es lo que hace posibles a los decoradores.\n\n### Construyendo un Decorador\nUn **decorador** es una función que toma otra función como argumento, le añade alguna funcionalidad (la 'decora') y devuelve una nueva función con el comportamiento extendido.\n```python\n# 1. El decorador es una función que recibe otra función\ndef mi_decorador(funcion_a_decorar):\n    # 2. Define una función 'envoltorio' o 'wrapper'\n    def wrapper():\n        print(\"Código que se ejecuta ANTES de la función original.\")\n        funcion_a_decorar() # 3. Llama a la función original\n        print(\"Código que se ejecuta DESPUÉS de la función original.\")\n    # 4. El decorador devuelve la función envoltorio\n    return wrapper\n\n# Usando el decorador con la sintaxis de '@'\n@mi_decorador\ndef saluda():\n    print(\"¡Hola desde la función 'saluda'!\")\n\nsaluda() # Al llamar a 'saluda', en realidad se está llamando a 'wrapper'\n```\nLa sintaxis `@mi_decorador` es un atajo para `saluda = mi_decorador(saluda)`.",
    "order_index": 1,
    "duration_minutes": 25
  },
  {
    "id": 27,
    "module_id": 10,
    "title": "Lección 2.2: Iteradores y Generadores para Procesamiento Eficiente",
    "content": "**Objetivo:** Aprender a procesar secuencias de datos de forma 'perezosa' (lazy evaluation) utilizando generadores, lo que ahorra memoria y mejora el rendimiento.\n\n### El Problema de las Listas Grandes\nImagina que necesitas procesar un millón de números. Crear una lista con todos ellos consumiría una gran cantidad de memoria RAM de una sola vez.\n```python\ndef crear_lista_numeros(maximo):\n    numeros = []\n    for i in range(maximo):\n        numeros.append(i)\n    return numeros\n\n# Esto podría consumir mucha memoria\n# gran_lista = crear_lista_numeros(1_000_000)\n```\n\n### La Solución Funcional: Generadores\nUn **generador** es un tipo especial de iterador que no almacena todos sus valores en memoria. En su lugar, 'genera' el siguiente valor sobre la marcha cada vez que se le pide. Se crean usando la palabra clave `yield` en una función.\n\n```python\ndef generar_numeros(maximo):\n    print(\"\\n(Iniciando generador...)\")\n    for i in range(maximo):\n        print(f\"(Generando {i}...)\")\n        yield i # Pausa la función y entrega el valor 'i'\n\n# El código del generador no se ejecuta hasta que se itera sobre él\nnumeros_generados = generar_numeros(3)\n\n# La iteración pide un valor a la vez\nfor num in numeros_generados:\n    print(f\"  Recibido en el bucle: {num}\")\n```\n`yield` pausa la función, entrega un valor y recuerda su estado. La próxima vez que se le pida un valor, reanuda la ejecución desde donde se quedó.",
    "order_index": 2,
    "duration_minutes": 25
  },
  {
    "id": 28,
    "module_id": 10,
    "title": "Lección 2.3: El Poder de `map` y `filter`",
    "content": "**Objetivo:** Dominar las funciones de orden superior clásicas del paradigma funcional para transformar y filtrar colecciones de datos de forma declarativa.\n\n'Declarativo' significa que describes *qué* quieres hacer, no *cómo* hacerlo paso a paso con un bucle `for`.\n\n### `map(funcion, iterable)`\nAplica una `funcion` a cada elemento de un `iterable` y devuelve un iterador con los resultados.\n```python\nnumeros = [1, 2, 3, 4]\n\n# Queremos una lista con el doble de cada número\ndobles = list(map(lambda x: x * 2, numeros))\nprint(dobles) # Salida: [2, 4, 6, 8]\n```\n\n### `filter(funcion, iterable)`\nDevuelve un iterador con solo los elementos del `iterable` para los cuales la `funcion` de condición devuelve `True`.\n```python\nnumeros = [1, 2, 3, 4, 5, 6]\n\n# Queremos una lista solo con los números pares\npares = list(filter(lambda x: x % 2 == 0, numeros))\nprint(pares) # Salida: [2, 4, 6]\n```\n\n### Combinando `map` y `filter`\nEl verdadero poder aparece al encadenar estas funciones para crear pipelines de datos.\n```python\n# Del 1 al 10, queremos el cuadrado solo de los números impares\nnumeros = range(1, 11)\n\n# 1. Filtramos los impares\nimpares = filter(lambda x: x % 2 != 0, numeros)\n\n# 2. Mapeamos los impares a su cuadrado\ncuadrados_de_impares = list(map(lambda x: x**2, impares))\n\nprint(cuadrados_de_impares) # Salida: [1, 9, 25, 49, 81]\n```",
    "order_index": 3,
    "duration_minutes": 25
  },
  {
    "id": 29,
    "module_id": 11,
    "title": "Lección 3.1: 'Pipelines' de Datos con Composición de Funciones",
    "content": "**Objetivo:** Aprender a encadenar operaciones funcionales para crear 'pipelines' de procesamiento de datos que sean limpios, legibles y fáciles de depurar.\n\nUn **pipeline de datos** es una serie de pasos de procesamiento donde la salida de un paso se convierte en la entrada del siguiente. El enfoque funcional es ideal para esto.\n\n### El Problema: Procesar Ventas\nImagina que tienes una lista de ventas y quieres calcular el total de ingresos de los productos electrónicos que costaron más de 500.\n```python\nventas = [\n    {'producto': 'Laptop', 'categoria': 'Electronica', 'precio': 1200},\n    {'producto': 'Libro', 'categoria': 'Libros', 'precio': 20},\n    {'producto': 'Monitor', 'categoria': 'Electronica', 'precio': 300},\n    {'producto': 'Teclado', 'categoria': 'Electronica', 'precio': 75},\n    {'producto': 'Smartphone', 'categoria': 'Electronica', 'precio': 800}\n]\n```\n\n### La Solución: Un Pipeline Funcional\nPodemos resolver esto encadenando `filter` y `map`.\n\n```python\n# Paso 1: Filtrar solo productos de 'Electronica' con precio > 500\nventas_relevantes = filter(\n    lambda v: v['categoria'] == 'Electronica' and v['precio'] > 500, \n    ventas\n)\n\n# Paso 2: Extraer (mapear) solo los precios de las ventas filtradas\nprecios_relevantes = map(lambda v: v['precio'], ventas_relevantes)\n\n# Paso 3: Sumar (reducir) todos los precios a un solo valor\ntotal_ingresos = sum(precios_relevantes) # sum() es una forma simple de reduce para sumas\n\nprint(f\"Total de ingresos de la selección: ${total_ingresos}\") # $2000\n```\nEste enfoque es **declarativo**: cada paso describe una acción clara. Es fácil de leer, probar y modificar cada etapa del pipeline de forma independiente.",
    "order_index": 1,
    "duration_minutes": 25
  },
  {
    "id": 30,
    "module_id": 11,
    "title": "Lección 3.2: Procesando Estructuras Anidadas con Enfoque Funcional",
    "content": "**Objetivo:** Usar herramientas funcionales como `map` y list comprehensions para procesar y transformar datos en estructuras anidadas de forma declarativa.\n\nProcesar datos anidados (ej. listas de diccionarios) con bucles `for` explícitos puede volverse complejo y difícil de leer. Un enfoque funcional a menudo resulta más claro.\n\n### El Problema: Extraer Datos de Usuarios\nTenemos una lista de usuarios, y cada usuario tiene una lista de correos. Queremos obtener una única lista plana con todos los correos electrónicos de todos los usuarios.\n```python\nusuarios = [\n    {\n        'id': 1, 'nombre': 'Ana', \n        'correos': ['ana.perez@email.com', 'aperez@work.com']\n    },\n    {\n        'id': 2, 'nombre': 'Luis', \n        'correos': ['luis.g@email.com']\n    }\n]\n```\n\n### Solución con List Comprehensions Anidadas\nLas comprensiones de listas pueden anidarse para 'aplanar' estructuras. Esta es la forma más 'Pythónica' y legible de lograrlo.\n```python\n# Para cada correo en la lista de correos de cada usuario...\nlista_plana_correos = [correo for usuario in usuarios for correo in usuario['correos']]\n\nprint(lista_plana_correos)\n# Salida: ['ana.perez@email.com', 'aperez@work.com', 'luis.g@email.com']\n```\n\n### Solución con `map` y `reduce` (Avanzado)\nTambién podemos lograrlo componiendo funciones. Esto es más avanzado y menos común para esta tarea específica, pero ilustra el poder del paradigma.\n```python\nfrom functools import reduce\n\n# 1. Mapeamos cada usuario a su lista de correos, obteniendo una lista de listas\nlistas_de_correos = map(lambda u: u['correos'], usuarios)\n\n# 2. Reducimos la lista de listas a una sola lista sumándolas\nlista_plana = reduce(lambda lista_acumulada, lista_actual: lista_acumulada + lista_actual, listas_de_correos)\nprint(lista_plana)\n```",
    "order_index": 2,
    "duration_minutes": 25
  },
  {
    "id": 31,
    "module_id": 11,
    "title": "Lección 3.3: Introducción a Expresiones Regulares (Regex)",
    "content": "**Objetivo:** Aprender a usar expresiones regulares para la limpieza, validación y extracción de patrones en datos de texto, un paso crucial en cualquier pipeline de datos.\n\nLas **expresiones regulares** (o Regex) son una secuencia de caracteres que define un patrón de búsqueda. Son una herramienta increíblemente poderosa para trabajar con texto, indispensable en tareas de limpieza y extracción de datos (data wrangling).\n\n### El Módulo `re` de Python\nPython proporciona el módulo `re` para trabajar con regex. Veamos algunas de sus funciones más comunes.\n\n**1. `re.search(patron, texto)`:** Busca el `patron` en cualquier parte del `texto`. Devuelve un objeto de coincidencia si lo encuentra, o `None` si no.\n```python\nimport re\n\ntexto = \"Mi número es 414-555-1234.\"\npatron = r\"\\d{3}-\\d{3}-\\d{4}\" # \\d es un dígito, {3} significa 3 veces\n\ncoincidencia = re.search(patron, texto)\nif coincidencia:\n    print(f\"Número de teléfono encontrado: {coincidencia.group(0)}\")\n```\n\n**2. `re.findall(patron, texto)`:** Encuentra **todas** las ocurrencias del `patron` que no se solapen y las devuelve como una lista de strings.\n```python\ntexto = \"Precios: $10.99, $25.50 y $5.00\"\npatron_precio = r\"\\$\\d+\\.\\d{2}\" # Busca un $, seguido de dígitos, un punto, y 2 dígitos\n\nprecios = re.findall(patron_precio, texto)\nprint(precios) # Salida: ['$10.99', '$25.50', '$5.00']\n```\n\n**3. `re.sub(patron, reemplazo, texto)`:** Busca el `patron` en el `texto` y lo reemplaza con el string `reemplazo`.\n```python\ntexto_sucio = \"  hola    mundo  \"\ntexto_limpio = re.sub(r\"\\s+\", \" \", texto_sucio).strip() # \\s+ busca uno o más espacios\nprint(texto_limpio) # Salida: \"hola mundo\"\n```",
    "order_index": 3,
    "duration_minutes": 25
  }
]
